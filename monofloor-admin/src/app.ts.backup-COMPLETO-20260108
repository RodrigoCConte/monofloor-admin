import express from 'express';
import cors from 'cors';
import path from 'path';
import { config } from './config';
import { PrismaClient } from '@prisma/client';

// Force rebuild: 2024-12-21T01:15:00Z - PostgreSQL file storage
import { errorHandler } from './middleware/errorHandler';
import { authRoutes } from './routes/auth.routes';
import { adminRoutes } from './routes/admin';
import { mobileRoutes } from './routes/mobile';
import { webhookRoutes } from './routes/webhooks';
import proposalsRoutes from './routes/proposals.routes';
import filesRoutes from './routes/files.routes';

const prisma = new PrismaClient();

const app = express();

// Request logging middleware
app.use((req, res, next) => {
  console.log(`üì• ${new Date().toISOString()} ${req.method} ${req.path}`);
  next();
});

// CORS configuration - whitelist allowed origins
const allowedOrigins = [
  config.cors.adminPanelUrl,
  config.cors.mobileAppUrl,
  'http://localhost:5173',
  'http://localhost:5174',
  'http://localhost:8080',
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:1111',
  // Production URLs
  'https://monofloor.com.br',
  'https://app.monofloor.com.br',
  'https://admin.monofloor.com.br',
  'https://devoted-wholeness-production.up.railway.app',
  // Hostinger VPS URLs
  'https://admin.monofloor.cloud',
  'https://app.monofloor.cloud',
  'http://app.monofloor.cloud:8081',
  'https://propostas.monofloor.cloud',
  'https://comercial.monofloor.cloud',
  // Capacitor iOS/Android native apps
  'capacitor://monofloor.app',
  'capacitor://localhost',
  'ionic://localhost',
  'http://localhost',
].filter(Boolean);

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);

    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      console.warn(`CORS blocked origin: ${origin}`);
      callback(null, false);
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
}));

// Handle OPTIONS preflight explicitly
app.options('*', cors());

// Body parsing (increased limit for base64 images)
app.use(express.json({ limit: '5mb' }));
app.use(express.urlencoded({ extended: true, limit: '5mb' }));

// Serve static files from uploads directory
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Serve video processor static files
app.use('/video-processor', express.static(path.join(__dirname, '../public/video-processor')));

// Serve propostas.html and other public static files
app.use(express.static(path.join(__dirname, '../public')));

// Serve admin panel static files (Vue.js build)
const adminPanelPath = path.join(__dirname, '../admin-panel/dist');
app.use('/admin', express.static(adminPanelPath));

// Handle admin panel SPA routing (all /admin/* routes serve index.html)
app.get('/admin/*', (req, res) => {
  res.sendFile(path.join(adminPanelPath, 'index.html'));
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    name: 'Monofloor Admin API',
    version: '1.0.0',
    status: 'online',
    docs: '/api',
  });
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/mobile', mobileRoutes);
app.use('/api/proposals', proposalsRoutes);
app.use('/api/webhooks', webhookRoutes);

// File serving from PostgreSQL database
app.use('/files', filesRoutes);

// Public proposal page route - serves pre-converted images with tracking
// Supports both old format (/p/abc123) and new format (/p/2026/Proposta_Nome_abc123)
app.get('/p/:slug(*)', async (req, res) => {
  try {
    const slug = req.params.slug;

    const proposta = await prisma.proposta.findUnique({
      where: { htmlSlug: slug },
      select: {
        id: true,
        htmlImages: true, // Imagens pr√©-convertidas
        comercial: {
          select: { personName: true }
        }
      }
    });

    if (!proposta) {
      return res.status(404).send(`
        <!DOCTYPE html>
        <html>
        <head><title>Proposta n√£o encontrada</title></head>
        <body style="font-family: sans-serif; text-align: center; padding: 50px; background: #000; color: #fff;">
          <h1>Proposta n√£o encontrada</h1>
          <p>Esta proposta pode ter expirado ou o link est√° incorreto.</p>
        </body>
        </html>
      `);
    }

    if (!proposta.htmlImages) {
      return res.status(404).send(`
        <!DOCTYPE html>
        <html>
        <head><title>Proposta n√£o dispon√≠vel</title></head>
        <body style="font-family: sans-serif; text-align: center; padding: 50px; background: #000; color: #fff;">
          <h1>Proposta n√£o dispon√≠vel</h1>
          <p>Esta proposta precisa ser regenerada. Por favor, solicite um novo link.</p>
        </body>
        </html>
      `);
    }

    // Registrar visualiza√ß√£o inicial (tracking)
    const userAgent = req.headers['user-agent'] || '';
    const ip = (req.headers['x-forwarded-for'] as string)?.split(',')[0] ||
               req.socket.remoteAddress || 'unknown';

    const botPatterns = [/bot/i, /crawler/i, /spider/i, /googlebot/i, /bingbot/i, /whatsapp/i, /facebookexternalhit/i, /Facebot/i, /Twitterbot/i, /LinkedInBot/i, /Slackbot/i, /TelegramBot/i];
    const isBot = botPatterns.some(p => p.test(userAgent));

    let deviceType = 'desktop';
    if (/mobile/i.test(userAgent)) deviceType = 'mobile';
    else if (/tablet|ipad/i.test(userAgent)) deviceType = 'tablet';

    const clienteName = proposta.comercial?.personName || 'Cliente';

    // Se for bot (WhatsApp, Facebook, etc), retornar HTML leve com apenas meta tags OG
    if (isBot) {
      console.log(`ü§ñ [Bot] ${userAgent.substring(0, 50)} acessando proposta ${slug}`);
      const ogHtml = generateBotFriendlyHTML(slug, clienteName);
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      return res.send(ogHtml);
    }

    const sessionId = require('crypto').randomBytes(16).toString('hex');

    await prisma.propostaView.create({
      data: {
        propostaId: proposta.id,
        ip,
        userAgent,
        deviceType,
        isBot,
        sessionId
      }
    });

    console.log(`üìä [Tracking] Proposta ${slug} visualizada - IP: ${ip}, Device: ${deviceType}`);

    // Usar imagens pr√©-convertidas (R√ÅPIDO!)
    const images: string[] = JSON.parse(proposta.htmlImages);
    console.log(`‚úÖ Carregando ${images.length} imagem(s) pr√©-convertidas`);

    // Gerar HTML com as imagens do PDF
    const html = generateProposalImageHTML(slug, sessionId, clienteName, images);

    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.send(html);

  } catch (error) {
    console.error('Erro ao buscar proposta:', error);
    res.status(500).send('Erro ao carregar proposta');
  }
});

// Fun√ß√£o para gerar HTML com imagens do PDF e tracking
function generateProposalImageHTML(slug: string, sessionId: string, clienteName: string, images: string[]): string {
  const totalPages = images.length;
  const imagesHtml = images.map((img, idx) => `
    <div class="page" data-page="${idx + 1}">
      <img src="${img}" alt="Proposta p√°gina ${idx + 1}" loading="lazy" />
    </div>
  `).join('');

  const ogTitle = `Proposta Monofloor - ${clienteName}`;
  const ogDescription = 'Um piso sem juntas √© um caminho sem volta.';
  const ogImage = 'https://propostas.monofloor.cloud/og-image.jpg';
  const ogUrl = `https://propostas.monofloor.cloud/p/${slug}`;

  return `<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${ogTitle}</title>

  <!-- Open Graph / WhatsApp / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="${ogUrl}">
  <meta property="og:title" content="${ogTitle}">
  <meta property="og:description" content="${ogDescription}">
  <meta property="og:image" content="${ogImage}">
  <meta property="og:image:width" content="800">
  <meta property="og:image:height" content="1185">
  <meta property="og:site_name" content="Monofloor">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${ogTitle}">
  <meta name="twitter:description" content="${ogDescription}">
  <meta name="twitter:image" content="${ogImage}">

  <link rel="icon" type="image/png" sizes="32x32" href="https://propostas.monofloor.cloud/favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://propostas.monofloor.cloud/apple-touch-icon.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 500px;
      width: 100%;
      background: #000;
    }

    .page {
      margin: 0;
      padding: 0;
      background: #000;
    }

    .page img {
      width: 100%;
      height: auto;
      display: block;
      margin: 0;
      padding: 0;
    }

    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 12px;
      background: #000;
    }

    .footer a {
      color: #c9a962;
      text-decoration: none;
    }

    @media (max-width: 600px) {
      .container { max-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    ${imagesHtml}

    <div class="footer">
      <p>Proposta Monofloor - ${clienteName}</p>
      <p style="margin-top: 8px;"><a href="https://monofloor.com.br" target="_blank">monofloor.com.br</a></p>
    </div>
  </div>

  <!-- Tracking Script with Page Analytics -->
  <script>
    (function() {
      const slug = '${slug}';
      const sessionId = '${sessionId}';
      const apiBase = window.location.origin;
      const totalPages = ${totalPages};

      let startTime = Date.now();
      let maxScroll = 0;
      let lastUpdate = 0;
      let currentPage = 1;
      let pageStartTime = Date.now();
      let isTabVisible = !document.hidden;
      let hiddenTime = 0; // Tempo total que a aba ficou oculta

      // Tracking de tempo por p√°gina
      const pageTimes = {};
      const pagesViewed = new Set();
      for (let i = 1; i <= totalPages; i++) {
        pageTimes[i] = 0;
      }

      // Formatador de tempo
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins + ':' + (secs < 10 ? '0' : '') + secs;
      }

      // Intersection Observer para detectar p√°gina vis√≠vel
      const pages = document.querySelectorAll('.page[data-page]');
      const observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
            const newPage = parseInt(entry.target.dataset.page);
            if (newPage !== currentPage) {
              // Salvar tempo da p√°gina anterior
              const timeOnPrevPage = Math.round((Date.now() - pageStartTime) / 1000);
              pageTimes[currentPage] = (pageTimes[currentPage] || 0) + timeOnPrevPage;

              // Atualizar para nova p√°gina
              currentPage = newPage;
              pageStartTime = Date.now();
              pagesViewed.add(newPage);
            }
          }
        });
      }, { threshold: 0.5 });

      pages.forEach(function(page) {
        observer.observe(page);
        if (page.dataset.page === '1') pagesViewed.add(1);
      });

      // Atualizar scroll
      function updateScroll() {
        const scrollTop = window.scrollY || document.documentElement.scrollTop;
        const docHeight = Math.max(document.body.scrollHeight - window.innerHeight, 1);
        const scrollPercent = Math.min(100, Math.round((scrollTop / docHeight) * 100));
        if (scrollPercent > maxScroll) maxScroll = scrollPercent;
      }

      window.addEventListener('scroll', updateScroll);
      updateScroll();

      // Enviar tracking
      function sendTracking(final) {
        // S√≥ atualizar tempo da p√°gina se a aba estiver vis√≠vel
        if (isTabVisible) {
          const timeOnCurrentPage = Math.round((Date.now() - pageStartTime) / 1000);
          pageTimes[currentPage] = (pageTimes[currentPage] || 0) + timeOnCurrentPage;
          pageStartTime = Date.now();
        }

        // Tempo real na p√°gina (excluindo tempo oculto)
        const timeOnPage = Math.round((Date.now() - startTime - hiddenTime) / 1000);
        if (!final && Date.now() - lastUpdate < 1000) return;
        lastUpdate = Date.now();

        const data = {
          slug: slug,
          sessionId: sessionId,
          timeOnPage: timeOnPage,
          scrollDepth: maxScroll,
          currentPage: currentPage,
          pageTimes: pageTimes,
          pagesViewed: Array.from(pagesViewed)
        };

        // Debug: Log para verificar dados enviados
        console.log('[Tracking] Enviando:', {
          time: timeOnPage,
          scroll: maxScroll,
          page: currentPage,
          pages: Object.keys(pageTimes).length,
          pageTimes: JSON.stringify(pageTimes)
        });

        if (final && navigator.sendBeacon) {
          navigator.sendBeacon(apiBase + '/api/proposals/track', new Blob([JSON.stringify(data)], { type: 'application/json' }));
        } else {
          fetch(apiBase + '/api/proposals/track', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
            keepalive: true
          }).then(function(res) {
            if (!res.ok) console.error('[Tracking] Erro:', res.status);
          }).catch(function(err) {
            console.error('[Tracking] Falha:', err);
          });
        }
      }

      setInterval(function() {
        if (isTabVisible) sendTracking(false);
      }, 5000);
      window.addEventListener('beforeunload', function() { sendTracking(true); });
      window.addEventListener('pagehide', function() { sendTracking(true); });

      // Pausar contagem quando aba n√£o est√° vis√≠vel
      let hiddenStartTime = null;
      document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
          isTabVisible = false;
          hiddenStartTime = Date.now();
          // Salvar tempo da p√°gina atual antes de ocultar
          const timeOnCurrentPage = Math.round((Date.now() - pageStartTime) / 1000);
          pageTimes[currentPage] = (pageTimes[currentPage] || 0) + timeOnCurrentPage;
          sendTracking(true);
        } else {
          isTabVisible = true;
          // Adicionar tempo oculto ao total de tempo ignorado
          if (hiddenStartTime) {
            hiddenTime += (Date.now() - hiddenStartTime);
            hiddenStartTime = null;
          }
          // Resetar pageStartTime para n√£o contar tempo oculto
          pageStartTime = Date.now();
        }
      });
      setTimeout(function() { sendTracking(false); }, 3000);

      // Expor fun√ß√µes para acesso externo
      window.proposalTracking = {
        getPageTimes: function() { return pageTimes; },
        getCurrentPage: function() { return currentPage; },
        getTotalTime: function() { return Math.round((Date.now() - startTime) / 1000); },
        getPagesViewed: function() { return Array.from(pagesViewed); }
      };
    })();
  </script>

  <!-- Session Recording (rrweb) -->
  <script>
    (function() {
      var sessionId = '${sessionId}';
      var slug = '${slug}';
      var apiBase = window.location.origin;
      var recordedEvents = [];
      var isRecording = false;

      // Carregar rrweb
      var rrwebScript = document.createElement('script');
      rrwebScript.src = 'https://cdn.jsdelivr.net/npm/rrweb@1.1.3/dist/rrweb.min.js';
      rrwebScript.onload = function() {
        isRecording = true;
        var hasSentFirstBatch = false;

        try {
          console.log('[rrweb] Initializing recording...');
          rrweb.record({
            emit: function(event, isCheckout) {
              recordedEvents.push(event);
              // Log para debug dos primeiros eventos
              if (recordedEvents.length <= 10) {
                console.log('[rrweb] Event #' + recordedEvents.length + ' type:', event.type, '(' + (event.type === 2 ? 'FullSnapshot' : event.type === 3 ? 'Incremental' : event.type === 4 ? 'Meta' : 'Other') + ')', isCheckout ? '(checkout)' : '');
              }
            },
            checkoutEveryNms: 10000, // For√ßar FullSnapshot a cada 10 segundos
            sampling: {
              mousemove: 50,
              mouseInteraction: true,
              scroll: 150,
              input: 'last'
            },
            maskAllInputs: true,
            recordCrossOriginIframes: false
          });
          console.log('[rrweb] Recording started, events so far:', recordedEvents.length);
        } catch (err) {
          console.error('[rrweb] Error starting recording:', err);
        }

        // Enviar primeiro batch ap√≥s 5 segundos (garante FullSnapshot)
        setTimeout(function() {
          if (recordedEvents.length > 0 && !hasSentFirstBatch) {
            var types = recordedEvents.map(function(e) { return e.type; });
            var hasFS = types.indexOf(2) !== -1;
            console.log('[rrweb] Sending FIRST batch with', recordedEvents.length, 'events. Types:', types.join(','), 'HasFullSnapshot:', hasFS);
            hasSentFirstBatch = true;
            sendRecordingBatch();
          }
        }, 5000);

        // Enviar ao sair da p√°gina (backup)
        window.addEventListener('beforeunload', function() {
          if (recordedEvents.length > 0) {
            sendRecordingBatch(true);
          }
        });

        // Enviar a cada 10 segundos para capturar mais eventos
        setInterval(function() {
          if (recordedEvents.length > 0 && hasSentFirstBatch) {
            console.log('[rrweb] Sending batch with', recordedEvents.length, 'events');
            sendRecordingBatch();
          }
        }, 10000);
      };
      rrwebScript.onerror = function() {
        console.error('[rrweb] Failed to load recording library');
      };
      document.head.appendChild(rrwebScript);

      function sendRecordingBatch(final) {
        if (recordedEvents.length === 0) return;

        var eventsToSend = recordedEvents.slice();
        recordedEvents = [];

        var data = {
          slug: slug,
          sessionId: sessionId,
          events: eventsToSend,
          isFinal: !!final
        };

        if (final && navigator.sendBeacon) {
          navigator.sendBeacon(apiBase + '/api/proposals/recording', new Blob([JSON.stringify(data)], { type: 'application/json' }));
        } else {
          fetch(apiBase + '/api/proposals/recording', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
            keepalive: true
          }).catch(function() {});
        }
      }
    })();
  </script>
</body>
</html>`;
}

// HTML leve para bots (WhatsApp, Facebook, etc) - apenas meta tags OG
function generateBotFriendlyHTML(slug: string, clienteName: string): string {
  const ogTitle = `Proposta Monofloor - ${clienteName}`;
  const ogDescription = 'Um piso sem juntas √© um caminho sem volta.';
  const ogImage = 'https://propostas.monofloor.cloud/og-image.jpg';
  const ogUrl = `https://propostas.monofloor.cloud/p/${slug}`;

  return `<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${ogTitle}</title>

  <!-- Open Graph / WhatsApp / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="${ogUrl}">
  <meta property="og:title" content="${ogTitle}">
  <meta property="og:description" content="${ogDescription}">
  <meta property="og:image" content="${ogImage}">
  <meta property="og:image:width" content="800">
  <meta property="og:image:height" content="1185">
  <meta property="og:site_name" content="Monofloor">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${ogTitle}">
  <meta name="twitter:description" content="${ogDescription}">
  <meta name="twitter:image" content="${ogImage}">

  <link rel="icon" type="image/png" sizes="32x32" href="https://propostas.monofloor.cloud/favicon-32x32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://propostas.monofloor.cloud/apple-touch-icon.png">
</head>
<body style="background: #000; color: #fff; font-family: sans-serif; text-align: center; padding: 50px;">
  <h1>${ogTitle}</h1>
  <p>${ogDescription}</p>
  <p><a href="${ogUrl}" style="color: #c9a962;">Abrir proposta</a></p>
</body>
</html>`;
}

// Error handling
app.use(errorHandler);

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      message: `Route ${req.method} ${req.path} not found`,
    },
  });
});

export { app };
